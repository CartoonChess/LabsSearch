//
//  ActionExtensionAddEditEngineTableViewController.swift
//  LabsSearch
//
//  Created by Xcode on ’18/10/28.
//  Copyright © 2018 Distant Labs. All rights reserved.
//

import UIKit
import MobileCoreServices // needed for kUTType

extension AddEditEngineTableViewController {
    
    // MARK: - Properties
    // They're in the main class declaration!
    
    
    // MARK: - Methods
    
    
    /// Retrieves the URL and page title from the host app via JavaScript.
    func loadUrl() {
        // TODO: Collapse all these into one guard statement after debugging
        
        // Get the item that the host app provides (extension item which also contains a plist)
        // Info.plist specifies we only want the first
        guard let item = extensionContext?.inputItems.first as? NSExtensionItem else {
            print(.x, "Failed to fetch input items.")
            return
        }
        print(.o, "Found \(extensionContext?.inputItems.count ?? 0) item(s); using first item \(item).")
        
        // Get the provider (attachment; should be a plist for us)
        guard let provider = item.attachments?.first else {
            print(.x, "Failed to fetch provider attachment from input items.")
            return
        }
        print(.o, "Found \(item.attachments?.count ?? 0) provider(s); got provider \(provider).")
        
        // We'll be using the plist generated by GetSharedUrl.js
        let plistType = String(kUTTypePropertyList)
        
        guard provider.hasItemConformingToTypeIdentifier(plistType) else {
            print(.x, "Provider could not provide item conforming to plist.")
            return
        }
        print(.o, "Provider has a plist.")
        
        // This is a plist. We'll load it, and get the pairs
        provider.loadItem(forTypeIdentifier: plistType, options: nil, completionHandler: { (item, error) in
            
            // Print the error, if one is provided
            if let error = error {
                print(.x, "Error loading plist from provider: \(error)")
            }
            
            // TODO: This or the next is JSON data; try to figure out which
            // Cast plist as dictionary (?)
            guard let dictionary = item as? NSDictionary else {
                print(.x, "Failed to cast plist as dictionary.")
                return
            }
            
            print(.o, "Cast plist as dictionary with keys \(dictionary.allKeys).")
            // TODO: Can we make this and the next a non-NS type?
            
            // Updates from the JSON file will be on the main queue
            // Presumably this is because we are no longer doing network fetches,
            // and are now going to update the UI
            
            // Note: It was recommended we use the `block` closure:
            // OperationQueue.main.addOperation({ //code; })
            // But I'm not sure we need to do that
            
            OperationQueue.main.addOperation {
                print(.o, "Loading plist and fetching values.")
                
                // Get results of GetSharedUrl.js ...
                guard let results = dictionary[NSExtensionJavaScriptPreprocessingResultsKey] as? NSDictionary else {
                    print(.x, "Failed to cast JSON results to dictionary.")
                    return
                }
                print(.o, "Cast JSON results as dictionary with keys \(results.allKeys).")
                
                // Set variables, if we can
                let url = results["url"] as? String
                let title = results["title"] as? String
                // Not using source code currently; have to edit JS file as well if needing this
                //let html = results["html"] as? String
                
                // Use web page title to fill in name field
                // TODO: We should parse this to try harder
                self.hostAppEngineName = title
                
                // Get URL to pass to URL details view
                self.hostAppUrlString = url
            }
            
        })
        
    }
    
    
    func updateView() {
        // Create an engine object with the URL, if it's testable
        // This will prevent pushing to the URL details view
        // FIXME: This can still probably fail and cause the URL details view to push when the JSON is slow
        
        // First, see if the URL is valid and that it contains the default magic word
        print(.o, "URL loaded from host app; checking validity.")
        if let url = urlController.validUrl(from: hostAppUrlString, schemeIsValid: { (url) -> Bool in
            return url.schemeIsCompatibleWithSafariView
        }),
            urlController.detectMagicWord(in: url) {
            
            print(.o, "URL and default magic word detected; creating engine object.")
            // Create engine object with URL, awaiting further details
            urlController.willUpdateUrlDetails(url: url.absoluteString) { (baseUrl, queries) in
                updateUrlDetails(baseUrl: baseUrl, queries: queries)
            }
            
        }
        
        // Update text fields
        updateNameTextField()
        updateShortcutTextField()
        
        updateSaveButton()
    }
    
    func updateNameTextField() {
        let name: String
        
        // Get the host app URL. If this fails, set the whole page title in the name field
        guard let url = hostAppUrlString,
            let components = URLComponents(string: url),
            let host = components.host else {
            print(.x, "Failed to get host from host app URL; setting name field to page title.")
            nameTextField.text = hostAppEngineName
                name = ""
            return
        }
        
        // Split the host into an array by periods AND hyphens
        var array = host.components(separatedBy: CharacterSet(charactersIn: ".-"))
        
        if array.isEmpty {
            name = "New Engine"
        } else if array.count == 1 {
            // In the unlikely case of no period (like "localhost"), just capitalize that
            name = array.first!.capitalized
        } else {
            // So long as there is more than one piece, delete the last item in the array (e.g. "com")
            array.removeLast()
            // If there is still more than one piece AND the first is www (e.g. wasn't "www.com"), delete the first item
            if array.count > 1 && array.first == "www" {
                array.removeFirst()
            }
            // Remove "m" (mobile)
            if array.count > 1 {
                array.removeAll { $0 == "m" }
            }
            // Set name as array items Capitalized and concatenated by spaces
            name = array.joined(separator: " ").capitalized
        }
        
        nameTextField.text = name
        print(.o, "Populated name field with \"\(name)\".")
    }
    
    func updateShortcutTextField() {
        // TODO: Should this change even after it's been set once, if the user changes the name field?
        
        // Create an array from the (lowercase) name field
        guard let name = nameTextField.text?.lowercased() else {
            print(.x, "Could not generate shortcut because name could not be read.")
            return
        }
        let nameCharacters = Array(name)
        
        var shortcut = ""
        
        // Add characters from the name one by one
        for character in nameCharacters {
            // Skip over spaces
            if character == " " { continue }
            
            shortcut += String(character)
            
            // Once the shortcut is unique, stop adding characters
            if shortcutIsValid(shortcut) { break }
        }
        
        shortcutTextField.text = shortcut
        print(.o, "Automatically set shortcut to \"\(shortcut)\".")
        
        // Update icon label
        print(.n, "Child: \"Shortcut changed.\"")
        shortcutChanged()
    }
    
    
    // MARK: - Navigation
    
    
    /// Dismiss the action extension and return to the host app.
    func returnToHostApp() {
        // TODO: Do we need to call this? Or is there a simpler way to dismiss the view altogether?
        self.extensionContext!.completeRequest(returningItems: nil, completionHandler: nil)
//        self.extensionContext!.completeRequest(returningItems: self.extensionContext!.inputItems, completionHandler: nil)
    }

    
}
