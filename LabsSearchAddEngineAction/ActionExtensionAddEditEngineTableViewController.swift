//
//  ActionExtensionAddEditEngineTableViewController.swift
//  LabsSearch
//
//  Created by Xcode on ’18/10/28.
//  Copyright © 2018 Distant Labs. All rights reserved.
//

import UIKit
import MobileCoreServices // needed for kUTType

class ActionExtensionAddEditEngineTableViewController: AddEditEngineTableViewController {
    
    // MARK: - Parameters
    
    // These details will be provided by the host app
    var hostAppEngineName: String?
    var hostAppUrlString: String?
//    var hostAppHtml: String?
    
    let urlController = UrlController()
    
    // MARK: - Methods
    
    override func viewDidLoad() {
        // In order to access allShortcuts, we must load up the engines plist
        // In the main app, this is already taken care of in MainViewController
        SearchEngines.shared.loadEngines()
        
        // As the parent class sets allEngines, we must call it AFTER loading engines above
        super.viewDidLoad()
        
        // Get all the info about the current web page
        loadUrl()
    }
    
    func loadUrl() {
        // TODO: Collapse all these into one guard statement after debugging
        
        // Get the item that the host app provides (extension item which also contains a plist)
        // Info.plist specifies we only want the first
        guard let item = extensionContext?.inputItems.first as? NSExtensionItem else {
            print(.x, "Failed to fetch input items.")
            return
        }
        print(.o, "Found \(extensionContext?.inputItems.count ?? 0) item(s); using first item \(item).")
        
        // Get the provider (attachment; should be a plist for us)
        guard let provider = item.attachments?.first else {
            print(.x, "Failed to fetch provider attachment from input items.")
            return
        }
        print(.o, "Found \(item.attachments?.count ?? 0) provider(s); got provider \(provider).")
        
        // We'll be using the plist generated by GetSharedUrl.js
        let plistType = String(kUTTypePropertyList)
        
        guard provider.hasItemConformingToTypeIdentifier(plistType) else {
            print(.x, "Provider could not provide item conforming to plist.")
            return
        }
        print(.o, "Provider has a plist.")
        
        // This is a plist. We'll load it, and get the pairs
        provider.loadItem(forTypeIdentifier: plistType, options: nil, completionHandler: { (item, error) in
            
            // Print the error, if one is provided
            if let error = error {
                print(.x, "Error loading plist from provider: \(error)")
            }
            
            // TODO: This or the next is JSON data; try to figure out which
            // Cast plist as dictionary (?)
            guard let dictionary = item as? NSDictionary else {
                print(.x, "Failed to cast plist as dictionary.")
                return
            }
            
            print(.o, "Cast plist as dictionary with keys \(dictionary.allKeys).")
            // TODO: Can we make this and the next a non-NS type?
            
            // Updates from the JSON file will be on the main queue
            // Presumably this is because we are no longer doing network fetches,
            // and are now going to update the UI
            
            // Note: It was recommended we use the `block` closure:
            // OperationQueue.main.addOperation({ //code; })
            // But I'm not sure we need to do that
            
            OperationQueue.main.addOperation {
                print(.o, "Loading plist and fetching values.")
                
                // Get results of GetSharedUrl.js ...
                guard let results = dictionary[NSExtensionJavaScriptPreprocessingResultsKey] as? NSDictionary else {
                    print(.x, "Failed to cast JSON results to dictionary.")
                    return
                }
                print(.o, "Cast JSON results as dictionary with keys \(results.allKeys).")
                
                // Set variables, if we can
                let url = results["url"] as? String
                let title = results["title"] as? String
                // TODO: Shoud this be a string or something else?
                //let html = results["html"] as? String
                
                // Use web page title to fill in name field
                // TODO: We should parse this to try harder
                self.hostAppEngineName = title
                
                // Get URL to pass to URL details view
                self.hostAppUrlString = url
            }
            
        })
        
    }
    
    
    // JSON appears to finish during viewDidLoad, viewWillAppear, or viewDidAppear.
    // We are adding view population code here twice because it goes out of sync otherwise
    //- It's redundant but hopefully it gives us a chance to populate before the viewer sees if quick
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        // Update the URL and text fields with the fetched info
        updateView()
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        
        // Since we're calling this twice, quit if it worked the first time
        if hostAppEngineName != nil {
            print(.n, "Already attempted on time to create engine object in viewWillAppear.")
            return
        }
        updateView()
    }
    
    
    func updateView() {
        // Create an engine object with the URL, if it's testable
        // This will prevent pushing to the URL details view
        // FIXME: This can still probably fail and cause the URL details view to push when the JSON is slow
        
        // First, see if the URL is valid and that it contains the default magic word
        print(.o, "URL loaded from host app; checking validity.")
        if let url = urlController.validUrl(from: hostAppUrlString, schemeIsValid: { (url) -> Bool in
            return url.schemeIsCompatibleWithSafariView
        }),
            urlController.detectMagicWord(in: url) {
            
            print(.o, "URL and default magic word detected; creating engine object.")
            // Create engine object with URL, awaiting further details
            urlController.willUpdateUrlDetails(url: url.absoluteString) { (baseUrl, queries) in
                updateUrlDetails(baseUrl: baseUrl, queries: queries)
            }
            
        }
        
        // Update text fields
        updateNameTextField()
        updateShortcutTextField()
        
        updateSaveButton()
    }
    
    func updateNameTextField() {
        self.nameTextField.text = hostAppEngineName
        print(.o, "Populated name field with \"\(hostAppEngineName ?? "nil")\".")
    }
    
    func updateShortcutTextField() {
        // TODO: Once we connect to user defaults, make sure this doesn't conflict
        //- (this will be written in the parent class)
        // TODO: Should this change even after it's been set once, if the user changes the name field?
        self.shortcutTextField.text = hostAppEngineName?.first?.description
        print(.o, "Automatically set shortcut to \"\(hostAppEngineName?.first?.description ?? "nil")\".")
        
        // Update icon label
        print(.n, "Child: \"Shortcut changed.\"")
        shortcutChanged()
    }
    
    
    // MARK: - Navigation buttons
    
    /// Return to host app without doing anything else.
    @IBAction func cancelButtonTapped() {
        returnToHostApp()
    }
    
    
    /// Save the engine, then return to the host app.
    @IBAction func saveButtonTapped() {
        // Imitate the logic of the unwind from the main app
        // This will supply the engine title and shortcut from the text fields to the object
        // TODO: Could we use an exit (unwind) segue here instead?
        prepareForAddEditEngineUnwind()
        
        // Double check the engine isn't nil (if it is, we've made a serious error!)
        // Note that this creates `engine` BY VALUE, so it must happen AFTER the prepare function above
        guard let engine = engine else {
            print(.x, "Attempting to save engine when engine is nil")
            return
        }
    
        // TODO: This logic is shared with AllEnginesTable in addEngine(); refactor?
        print(.o, "Adding engine \(engine.name).")
        let shortcut = engine.shortcut
        
        // Add to shared object
        SearchEngines.shared.allEngines[shortcut] = engine
        
        // Update save data
        SearchEngines.shared.saveEngines()
        
        // Tell main app it needs to refresh data when returned to foreground
        UserDefaults(suiteName: AppKeys.appGroup)?.set(true, forKey: SettingsKeys.extensionDidChangeData)
        
        
        // Return to host app
        returnToHostApp()
    }
    
    
    /// Dismiss the action extension and return to the host app.
    func returnToHostApp() {
        // TODO: Do we need to call this? Or is there a simpler way to dismiss the view altogether?
        self.extensionContext!.completeRequest(returningItems: nil, completionHandler: nil)
//        self.extensionContext!.completeRequest(returningItems: self.extensionContext!.inputItems, completionHandler: nil)
    }
    
    
    // MARK: - Navigation
    
    // Pass the host app's URL to the URL details view if we haven't yet set one
    override func prepareForUrlDetailsSegue(_ segue: UIStoryboardSegue) {
        super.prepareForUrlDetailsSegue(segue)
        
        guard let destination = segue.destination as? ActionExtensionUrlDetailsTableViewController else {
            print(.x, "Expecting to segue to app extension URL details view but found different view type.")
            return
        }
        
        if engine == nil {
            destination.hostAppUrlString = hostAppUrlString
        }
    }

    
}
