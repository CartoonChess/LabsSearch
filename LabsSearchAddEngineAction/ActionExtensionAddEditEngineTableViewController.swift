//
//  ActionExtensionAddEditEngineTableViewController.swift
//  LabsSearch
//
//  Created by Xcode on ’18/10/28.
//  Copyright © 2018 Distant Labs. All rights reserved.
//

import UIKit
import MobileCoreServices // needed for kUTType

extension AddEditEngineTableViewController {
    
    // MARK: - Properties
    // They're in the main class declaration!
    
    
    // MARK: - Methods
    
    
    /// Retrieves the URL and page title from the host app via JavaScript.
    func loadUrl() {
        // TODO: Collapse all these into one guard statement after debugging
        
        // Get the item that the host app provides (extension item which also contains a plist)
        // Info.plist specifies we only want the first
        guard let item = extensionContext?.inputItems.first as? NSExtensionItem else {
            print(.x, "Failed to fetch input items.")
            return
        }
        print(.o, "Found \(extensionContext?.inputItems.count ?? 0) item(s); using first item \(item).")
        
        // Get the provider (attachment; should be a plist for us)
        guard let provider = item.attachments?.first else {
            print(.x, "Failed to fetch provider attachment from input items.")
            return
        }
        print(.o, "Found \(item.attachments?.count ?? 0) provider(s); got provider \(provider).")
        
        // We'll be using the plist generated by GetSharedUrl.js
        let plistType = String(kUTTypePropertyList)
        
        guard provider.hasItemConformingToTypeIdentifier(plistType) else {
            print(.x, "Provider could not provide item conforming to plist.")
            return
        }
        print(.o, "Provider has a plist.")
        
        // This is a plist. We'll load it, and get the pairs
        provider.loadItem(forTypeIdentifier: plistType, options: nil, completionHandler: { (item, error) in
            
            // Print the error, if one is provided
            if let error = error {
                print(.x, "Error loading plist from provider: \(error)")
            }
            
            // TODO: This or the next is JSON data; try to figure out which
            // Cast plist as dictionary (?)
            guard let dictionary = item as? NSDictionary else {
                print(.x, "Failed to cast plist as dictionary.")
                return
            }
            
            print(.o, "Cast plist as dictionary with keys \(dictionary.allKeys).")
            // TODO: Can we make this and the next a non-NS type?
            
            // Updates from the JSON file will be on the main queue
            // Presumably this is because we are no longer doing network fetches,
            // and are now going to update the UI
            
            // Note: It was recommended we use the `block` closure:
            // OperationQueue.main.addOperation({ //code; })
            // But I'm not sure we need to do that
            
            OperationQueue.main.addOperation {
                print(.o, "Loading plist and fetching values.")
                
                // Get results of GetSharedUrl.js ...
                guard let results = dictionary[NSExtensionJavaScriptPreprocessingResultsKey] as? NSDictionary else {
                    print(.x, "Failed to cast JSON results to dictionary.")
                    return
                }
                print(.o, "Cast JSON results as dictionary with keys \(results.allKeys).")
                
                // Set variables, if we can
                let url = results["url"] as? String
                let title = results["title"] as? String
                let html = results["html"] as? String
                
                // Use web page title to fill in name field
                self.hostAppEngineName = title
                
                // Get URL to pass to URL details view
                self.hostAppUrlString = url
                
                // Save HTML to try and find favicon or similar
                self.hostAppHtml = html
                
//                // Pass URL to the icon fetcher
//                guard let urlString = url,
//                    let (fetchableUrl, host) = self.iconFetcher.getUrlComponents(urlString) else {
//                        return
//                }
//
//                // Tell AddEditEngine VC to use the IconFetcher and update its view after fetching icon from server
//                self.updateIcon(for: fetchableUrl, host: host)
                
                // Pass URL to the icon fetch
                self.prepareToUpdateIcon(for: url)
            }
            
        })
        
    }
    
    
//    func updateView() {
//        // Create an engine object with the URL, if it's testable
//        // This will prevent pushing to the URL details view
//        // FIXME : This can still probably fail and cause the URL details view to push when the JSON is slow
//        
//        // First, see if the URL is valid and that it contains the default magic word
//        print(.o, "URL loaded from host app; checking validity.")
//        if let url = urlController.validUrl(from: hostAppUrlString, schemeIsValid: { (url) -> Bool in
//            return url.schemeIsCompatibleWithSafariView
//        }),
//            urlController.detectMagicWord(in: url) {
//            
//            print(.o, "URL and default magic word detected; creating engine object.")
//            // Create engine object with URL, awaiting further details
//            urlController.willUpdateUrlDetails(url: url.absoluteString) { (baseUrl, queries) in
//                updateUrlDetails(baseUrl: baseUrl, queries: queries)
//            }
//            
//        }
//        
//        // Update text fields
//        
//        // Get the host app URL. If this fails, set the whole page title in the name field
//        if let url = hostAppUrlString,
//            let name = makeEngineName(from: url) {
//            nameTextField.text = name
//        } else {
//            print(.x, "Failed to get host from host app URL; setting name field to page title.")
//            nameTextField.text = hostAppEngineName
//        }
//        shortcutTextField.text = makeEngineShortcut()
//        
//        // Must call this after to make sure the shortcut field is validated properly
//        shortcutChanged()
//        updateSaveButton()
//    }
    
    
    // MARK: - Navigation
    
    
    /// Dismiss the action extension and return to the host app.
    func returnToHostApp() {
        // TODO: Do we need to call this? Or is there a simpler way to dismiss the view altogether?
        self.extensionContext!.completeRequest(returningItems: nil, completionHandler: nil)
//        self.extensionContext!.completeRequest(returningItems: self.extensionContext!.inputItems, completionHandler: nil)
    }

    
}
