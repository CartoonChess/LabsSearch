//
//  ActionExtensionUrlDetailsTableViewController.swift
//  LabsSearch
//
//  Created by Xcode on ’18/10/30.
//  Copyright © 2018 Distant Labs. All rights reserved.
//

import UIKit
//import MobileCoreServices // needed for kUTType

class ActionExtensionUrlDetailsTableViewController: UrlDetailsTableViewController {
    
    // MARK: - Properties
    
    /// The URL sent from the host app, if it exists.
    ///
    /// This will be `nil` if the host app didn't send a URL or if the user has already set their own.
    var hostAppUrlString: String?
    
    
    // MARK: - Methods
    
    override func viewDidLoad() {
        // Fetch URL details from host app if a SearchEngine object has yet to be created
        if engine == nil {
//            loadUrl()
            // Set URL to that which is provided by the host app if we haven't already made our own
            urlTextField.text = hostAppUrlString
        }
        
        // Super must be called after child's instructions, or else URL testing will happen before it's set
        super.viewDidLoad()
    }
    
    
//    func loadUrl() {
//        // TODO: Collapse all these into one guard statement after debugging
//
//        // Get the item that the host app provides (extension item which also contains a plist)
//        // Info.plist specifies we only want the first
//        guard let item = extensionContext?.inputItems.first as? NSExtensionItem else {
//            print(.x, "Failed to fetch input items.")
//            return
//        }
//        print(.o, "Found \(extensionContext?.inputItems.count ?? 0) item(s); using first item \(item).")
//
//        // Get the provider (attachment; should be a plist for us)
//        guard let provider = item.attachments?.first else {
//            print(.x, "Failed to fetch provider attachment from input items.")
//            return
//        }
//        print(.o, "Found \(item.attachments?.count ?? 0) provider(s); got provider \(provider).")
//
//        // We'll be using the plist generated by GetSharedUrl.js
//        let plistType = String(kUTTypePropertyList)
//
//        guard provider.hasItemConformingToTypeIdentifier(plistType) else {
//            print(.x, "Provider could not provide item conforming to plist.")
//            return
//        }
//        print(.o, "Provider has a plist.")
//
//        // This is a plist. We'll load it, and get the pairs
//        provider.loadItem(forTypeIdentifier: plistType, options: nil, completionHandler: { (item, error) in
//
//            // Print the error, if one is provided
//            if let error = error {
//                print(.x, "Error loading plist from provider: \(error)")
//            }
//
//            // TODO: This or the next is JSON data; try to figure out which
//            // Cast plist as dictionary (?)
//            guard let dictionary = item as? NSDictionary else {
//                print(.x, "Failed to cast plist as dictionary.")
//                return
//            }
//
//            print(.o, "Cast plist as dictionary with keys \(dictionary.allKeys).")
//            // TODO: Can we make this and the next a non-NS type?
//
//            // Updates from the JSON file will be on the main queue
//            // Presumably this is because we are no longer doing network fetches,
//            // and are now going to update the UI
//
//            // Note: It was recommended we use the `block` closure:
//            // OperationQueue.main.addOperation({ //code; })
//            // But I'm not sure we need to do that
//
//            OperationQueue.main.addOperation {
//                print(.o, "Loading plist and fetching values.")
//
//                // Get results of GetSharedUrl.js ...
//                guard let results = dictionary[NSExtensionJavaScriptPreprocessingResultsKey] as? NSDictionary else {
//                    print(.x, "Failed to cast JSON results to dictionary.")
//                    return
//                }
//                print(.o, "Cast JSON results as dictionary with keys \(results.allKeys).")
//
//                // Set variables, if we can
//                let url = results["url"] as? String
//                let title = results["title"] as? String
//                // TODO: Shoud this be a string or something else?
//                //let html = results["html"] as? String
//
//                // Update view
//                self.urlTextField.text = url
//                // DEBUG
//                self.magicWordTextField.text = title
//            }
//
//        })
//
//    }

    
    
//    print(.o, "Found \(extensionContext!.inputItems.count) item(s); using first item \(item).")
//
//
//    /*** DEBUG ***/
//    print(.n, "⚠️ ⚠️ ⚠️ ⚠️")
//    print(.n, "attributedTitle: \(item.attributedTitle ?? NSAttributedString(string: "nil"))")
//    print(.n, "⚠️ ⚠️ ⚠️ ⚠️")
//    if let userInfo = item.userInfo {
//        for (key, value) in userInfo {
//            print(.n, "userInfo key: \(key) ; value: \(value)")
//        }
//    }
//    print(.n, "⚠️ ⚠️ ⚠️ ⚠️")
//    print(.n, "attributedContentText: \(item.attributedContentText ?? NSAttributedString(string: "nil"))")
//    print(.n, "⚠️ ⚠️ ⚠️ ⚠️")
//    if let attachments = item.attachments {
//        for attachment in attachments {
//            print(.n, "Attachment: \(attachment)")
//        }
//    }
//    print(.n, "⚠️ ⚠️ ⚠️ ⚠️")
//    /*** END DEBUG ***/
    
    
    
//    func __foo() {
//        var urlFound = false
//        for item in self.extensionContext!.inputItems as! [NSExtensionItem] {
//            print(.o, "Found \(self.extensionContext!.inputItems.count) item(s); got item \(item).")
//            for provider in item.attachments! {
//                print(.o, "Found \(item.attachments!.count) provider(s); got provider \(provider).")
//                if provider.hasItemConformingToTypeIdentifier(kUTTypeURL as String) {
//                    print(.o, "Provider has a URL.")
//                    // This is a URL. We'll load it, then place it in our text field
//                    weak var weakTextField = self.urlTextField
//                    provider.loadItem(forTypeIdentifier: kUTTypeURL as String, options: nil, completionHandler: { (url, error) in
//                        OperationQueue.main.addOperation {
//                            print(.o, "Loading item and adding operation.")
//                            if let strongTextField = weakTextField {
//                                print(.o, "Strong text field assigned weak text field.")
//                                if let url = url as? URL {
//                                    print(.o, "URL fetched; setting text field string.")
//                                    strongTextField.text = url.absoluteString
//                                }
//                            }
//                        }
//                    })
//
//                    urlFound = true
//                    break
//                }
//            }
//
//            if (urlFound) {
//                print(.o, "URL found.")
//                // We only handle one URL, so stop looking for more.
//                break
//            }
//        }
//    }
    
    
}
