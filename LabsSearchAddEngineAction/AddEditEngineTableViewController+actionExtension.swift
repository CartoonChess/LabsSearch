//
//  ActionExtensionAddEditEngineTableViewController.swift
//  LabsSearch
//
//  Created by Xcode on â€™18/10/28.
//  Copyright Â© 2018 Distant Labs. All rights reserved.
//

import UIKit
import MobileCoreServices // needed for kUTType

extension AddEditEngineTableViewController {
    
    // MARK: - Properties
    // They're in the main class declaration!
    
    
    // MARK: - Methods
    
    
    /// Retrieves the URL and page title from the host app via JavaScript.
    func loadUrl() {
        // TODO: Collapse all these into one guard statement after debugging
        
        // Get the item that the host app provides (extension item which also contains a plist)
        // Info.plist specifies we only want the first
        guard let item = extensionContext?.inputItems.first as? NSExtensionItem else {
            print(.x, "Failed to fetch input items.")
            return
        }
        print(.o, "Found \(extensionContext?.inputItems.count ?? 0) item(s); using first item \(item).")
        
        // Get the provider (attachment; should be a plist for us)
        guard let provider = item.attachments?.first else {
            print(.x, "Failed to fetch provider attachment from input items.")
            return
        }
        print(.o, "Found \(item.attachments?.count ?? 0) provider(s); got provider \(provider).")
        
        // We'll be using the plist generated by GetSharedUrl.js
        let plistType = String(kUTTypePropertyList)
        
        guard provider.hasItemConformingToTypeIdentifier(plistType) else {
            print(.x, "Provider could not provide item conforming to plist.")
            return
        }
        print(.o, "Provider has a plist.")
        
        // This is a plist. We'll load it, and get the pairs
        provider.loadItem(forTypeIdentifier: plistType, options: nil, completionHandler: { (item, error) in
            
            // Print the error, if one is provided
            if let error = error {
                print(.x, "Error loading plist from provider: \(error)")
            }
            
            // TODO: This or the next is JSON data; try to figure out which
            // Cast plist as dictionary (?)
            guard let dictionary = item as? NSDictionary else {
                print(.x, "Failed to cast plist as dictionary.")
                return
            }
            
            print(.o, "Cast plist as dictionary with keys \(dictionary.allKeys).")
            // TODO: Can we make this and the next a non-NS type?
            
            // Updates from the JSON file will be on the main queue
            // Presumably this is because we are no longer doing network fetches,
            // and are now going to update the UI
            
            // Note: It was recommended we use the `block` closure:
            // OperationQueue.main.addOperation({ //code; })
            // But I'm not sure we need to do that
            
            OperationQueue.main.addOperation {
                print(.o, "Loading plist and fetching values.")
                
                // Get results of GetSharedUrl.js ...
                guard let results = dictionary[NSExtensionJavaScriptPreprocessingResultsKey] as? NSDictionary else {
                    print(.x, "Failed to cast JSON results to dictionary.")
                    return
                }
                print(.o, "Cast JSON results as dictionary with keys \(results.allKeys).")
                
                // Set variables, if we can
                let url = results["url"] as? String
                let title = results["title"] as? String
                let characterEncoding = results["characterEncoding"] as? String
                let html = results["html"] as? String
                
                // Use web page title to fill in name field
                self.hostAppEngineName = title
                
                // Get URL to pass to URL details view
                self.hostAppUrlString = url

//                // Get character encoding
//                // TODO: Use Editor.updateCharacterEncoding!!!
//                // Adapted from OpS version (in turn from UrlDetails...)
//
//                // First, check if URL contains non-UTF characters
//                // If it does, set invalid encoding, in case a real one isn't found later
//                var urlEncoder: CharacterEncoder?
//                if url?.removingPercentEncoding == nil {
//                    let invalidEncoding = CharacterEncoding(name: "invalid utf-8", value: .invalid)
//                    urlEncoder = CharacterEncoder(encoding: invalidEncoding)
//                    self.searchEngineEditor.characterEncoder = urlEncoder
//                }
//                // Next, decide which encoding to use
//                if let remoteEncoding = characterEncoding,
//                    let remoteEncoder = CharacterEncoder(encoding: remoteEncoding) {
//
//                    switch (remoteEncoder.encoding.value, urlEncoder?.encoding.value) {
//                    case (.utf8, String.Encoding.invalid):
//                        // Keep invalid utf-8
//                        break
//                    default:
//                        self.searchEngineEditor.characterEncoder = remoteEncoder
//                    }
//                }
                
                // Update encoding, if found, and keep non-UTF URLs valid
                if let url = url {
                    // First, assume no encoding was found
                    var encoder = CharacterEncoder(encoding: "") // nil
                    // And only create a real encoder if we found an encoding
                    if let characterEncoding = characterEncoding {
                        encoder = CharacterEncoder(encoding: characterEncoding)
                    }
                    
                    // Update encoding if found, otherwise at least check URL
                    //- No encoding (or UTF-8) with non-UTF URL will set "invalid utf-8"
                    self.searchEngineEditor.updateCharacterEncoding(encoder: encoder, urlString: url, allowNilEncoder: true)
                }
                
                // Save HTML to try and find favicon or similar
                self.hostAppHtml = html
                self.searchEngineEditor.html = html
//                print(.d, "(Ext)AddEditTVC html: \(html != nil ? String("ðŸ’š") : String("ðŸ’”"))")
//                print(.d, "(Ext)AddEditTVC searchEngineEditor.html: \(self.searchEngineEditor.html != nil ? String("ðŸ’š") : String("ðŸ’”"))")
//                print(.d, "(Ext)AddEditTVC characterEncoding: \(characterEncoding ?? "ðŸ’”")")
                
//                // Pass URL to the icon fetcher
//                guard let urlString = url,
//                    let (fetchableUrl, host) = self.iconFetcher.getUrlComponents(urlString) else {
//                        return
//                }
//
//                // Tell AddEditEngine VC to use the IconFetcher and update its view after fetching icon from server
//                self.updateIcon(for: fetchableUrl, host: host)
                
                // Pass URL to the icon fetch
                self.prepareToUpdateIcon(for: url)
            }
            
        })
        
    }
    
    
//    func updateView() {
//        // Create an engine object with the URL, if it's testable
//        // This will prevent pushing to the URL details view
//        // FIXME : This can still probably fail and cause the URL details view to push when the JSON is slow
//        
//        // First, see if the URL is valid and that it contains the default magic word
//        print(.o, "URL loaded from host app; checking validity.")
//        if let url = urlController.validUrl(from: hostAppUrlString, schemeIsValid: { (url) -> Bool in
//            return url.schemeIsCompatibleWithSafariView
//        }),
//            urlController.detectMagicWord(in: url) {
//            
//            print(.o, "URL and default magic word detected; creating engine object.")
//            // Create engine object with URL, awaiting further details
//            urlController.willUpdateUrlDetails(url: url.absoluteString) { (baseUrl, queries) in
//                updateUrlDetails(baseUrl: baseUrl, queries: queries)
//            }
//            
//        }
//        
//        // Update text fields
//        
//        // Get the host app URL. If this fails, set the whole page title in the name field
//        if let url = hostAppUrlString,
//            let name = makeEngineName(from: url) {
//            nameTextField.text = name
//        } else {
//            print(.x, "Failed to get host from host app URL; setting name field to page title.")
//            nameTextField.text = hostAppEngineName
//        }
//        shortcutTextField.text = makeEngineShortcut()
//        
//        // Must call this after to make sure the shortcut field is validated properly
//        shortcutChanged()
//        updateSaveButton()
//    }
    
    
    // MARK: - Navigation
    
    
    /// Dismiss the action extension and return to the host app.
    func returnToHostApp() {
        // TODO: Do we need to call this? Or is there a simpler way to dismiss the view altogether?
        self.extensionContext!.completeRequest(returningItems: nil, completionHandler: nil)
//        self.extensionContext!.completeRequest(returningItems: self.extensionContext!.inputItems, completionHandler: nil)
    }

    
}
